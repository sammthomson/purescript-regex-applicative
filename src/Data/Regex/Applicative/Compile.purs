module Data.Regex.Applicative.Compile
  ( Thread
  , CompiledRe
  , emptyRe
  , compile
  , threads
  , failed
  , getResult
  , results
  , step
  , fromThreads
  , addThread
  ) where

import Control.Applicative (map, pure, (<*), (<*>))
import Control.Monad.Cont (ContT(..), runContT)
import Control.Monad.State (State, evalState, gets, modify)
import Control.Plus (empty, (<|>))
import Data.Foldable (foldl)
import Data.List.Lazy (List, fromFoldable, mapMaybe, nil, null, singleton)
import Data.Maybe (Maybe(..))
import Data.Regex.Applicative.StateQueue as SQ
import Data.Regex.Applicative.Types (Greediness(..), Re, ThreadId(..), elimRe, mkSymbol, mkStar)
import Data.Tuple (Tuple(..))
import Prelude (class Functor, class Semigroup, bind, flip, ($), (+), (<$>))


-- | A `Thread` is an intermediate state in the process of
-- | applying a regex to an input string.
-- | It is either an `Accept` state with a result of type `r`, or a
-- | (non-deterministic) transition function of the next input symbol.
data Thread c r =
  Thread
    { threadId :: ThreadId
    , step :: c -> CompiledRe c r
    }
  | Accept r

derive instance functorThread :: Functor (Thread c)

-- | Return the result of a thread, or `Nothing` if it's not an `Accept`.
getResult :: forall c r. Thread c r -> Maybe r
getResult (Accept r) = Just r
getResult (Thread _) = Nothing

-- | Feed a symbol into a thread.
stepThread :: forall c r. Thread c r -> c -> CompiledRe c r
stepThread (Thread t) c = t.step c
stepThread (Accept _) _ = emptyRe


-- | A `Re c r` that has been compiled into a non-deterministic state machine.
-- | `c` is the type of input symbols and `r` is the result type.
-- | A `CompiledRe` is implemented as a priority queue of `Thread`s.
-- | Threads generated by the left part of `<|>` have higher
-- | priority than threads generated by the right part, for example.
-- | Each non-result thread has a unique id, corresponding to the Symbol it
-- | is hoping to match next.
newtype CompiledRe c r = CompiledRe (SQ.StateQueue (Thread c r))

derive instance functorCompiledRe :: Functor (CompiledRe c)

emptyRe :: forall c r. CompiledRe c r
emptyRe = CompiledRe SQ.empty

-- | List of all threads of a `CompiledRe`.
threads :: forall c r. CompiledRe c r -> List (Thread c r)
threads (CompiledRe sq) = fromFoldable sq

-- | Create a `CompiledRe` from a list of threads. It is recommended that all
-- | threads come from the same `CompiledRe`, unless you know what you're doing.
-- | However, it should be safe to filter out or rearrange threads.
fromThreads :: forall c r. List (Thread c r) -> CompiledRe c r
fromThreads ts = foldl addThread emptyRe ts

-- | Check if the `CompiledRe` has no threads, in which case it will never match.
failed :: forall c r. CompiledRe c r -> Boolean
failed obj = null $ threads obj

-- | Extract the result values from all the result threads of a `CompiledRe`
results :: forall c r. CompiledRe c r -> List r
results obj = mapMaybe getResult $ threads obj

-- | Feed a symbol into a `CompiledRe`.
step :: forall c r. CompiledRe c r -> c -> CompiledRe c r
step (CompiledRe sq) c = foldl op emptyRe $ sq where
  op acc t = foldl addThread acc $ threads $ stepThread t c

-- | Add a thread to a `CompiledRe`. The new thread will have lower priority than the
-- | threads which are already in the `CompiledRe`.
-- | If a thread with the same id already exists in the queue, the
-- | `CompiledRe` is not changed.
addThread :: forall c r. CompiledRe c r -> Thread c r -> CompiledRe c r
addThread (CompiledRe q) t = CompiledRe $
  case t of
    Accept _ -> SQ.insert t q
    Thread { threadId: ThreadId i } -> SQ.insertUnique i t q


-- During parsing we need to remember if a result is due to an empty
-- match or a non-empty match, otherwise a Star whose inner regex matches
-- epsilon will loop forever.
type Result r = Tuple MaybeEmpty r

data MaybeEmpty = Empty | NotEmpty

instance semigroupEmpty :: Semigroup MaybeEmpty where
  append Empty x = x  -- only Empty if both are Empty
  append NotEmpty _ = NotEmpty

-- | Compile a regular expression into a non-deterministic state machine.
compile :: forall c r. Re c r -> CompiledRe c r
compile e = fromThreads $ runGo (renumber e) accept where
  accept (Tuple _ r) = singleton (Accept r)  -- base case

  runGo :: forall a. Re c a -> (Result a -> List (Thread c r)) -> List (Thread c r)
  runGo r = runContT $ go r

  -- | Builds a `CompiledRe` using continuation passing style.
  -- | Given a regex `re` and continuation `k`, `go` compiles `r` into a list
  -- | of threads, but replaces `Accept r` states with `k r`.
  go :: forall a. Re c a -> ContT (Thread c r) List (Result a)
  go = elimRe
    { eps: \a -> pure $ Tuple Empty a
    , fail: ContT \_ -> nil
    , symbol: \i p ->
        ContT \k -> singleton $ Thread
          { threadId: i
          , step: \c -> case p c of
              Nothing -> emptyRe
              Just a -> fromThreads $ k $ Tuple NotEmpty a
          }
    , alt: \ra rb -> ContT $ (<|>) <$> runGo ra <*> runGo rb  -- uses applyFn
    , app: \rf ra -> do
        f <- go rf
        a <- go ra
        pure $ f <*> a  -- uses applyTuple
    , star: \g op z r ->
        let
          rThen = runGo r
          or = case g of
            Greedy -> flip (<|>)
            NonGreedy -> (<|>)
          star a k =
            k a  -- match `r` zero times
            `or`
            rThen case _ of  -- match `r` at least once
              Tuple Empty _ -> nil  -- we don't allow `r` to empty match
              b -> star (op <$> a <*> b) k  -- uses applyTuple
        in
          ContT $ star (Tuple Empty z)
    , map: \f r -> map f <$> go r
    }

-- | Give each `Symbol` node a unique `ThreadId`.
renumber :: forall c r. Re c r -> Re c r
renumber e =
  let
    fresh :: State Int ThreadId
    fresh = gets ThreadId <* (modify $ (+) 1)
    go :: forall t b. Re t b -> State Int (Re t b)
    go = elimRe
      { eps: \a -> pure $ pure a
      , fail: pure empty
      , symbol: \_ p -> flip mkSymbol p <$> fresh  -- <-- fresh
      , alt: \a1 a2 -> (<|>) <$> go a1 <*> go a2
      , app: \a1 a2 -> (<*>) <$> go a1 <*> go a2
      , star: \g f b a -> mkStar g f b <$> go a
      , map: \f a -> (<$>) f <$> go a
    }
  in
    evalState (go e) 0
