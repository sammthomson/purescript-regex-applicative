module Data.Regex.Applicative.Compile
  ( Thread
  , CompiledRe
  , emptyRe
  , compile
  , threads
  , failed
  , getResult
  , results
  , step
  , fromThreads
  , addThread
  ) where

import Control.Applicative (pure, (<*), (<*>))
import Control.Monad.Cont (Cont, cont, runCont)
import Control.Monad.State (State, evalState, gets, modify)
import Control.Plus (empty, (<|>))
import Data.Foldable (foldl)
import Data.List.Lazy (List, fromFoldable, mapMaybe, nil, null, (:))
import Data.Maybe (Maybe(..), maybe)
import Data.Regex.Applicative.StateQueue as SQ
import Data.Regex.Applicative.Types (Greediness(..), RE(Symbol), ThreadId(..), elimRE, mkStar)
import Prelude (class Functor, const, flip, ($), (+), (<$>), (>>>))


-- | A `Thread` is one intermediate state (of possibly many) in the process of
-- | applying a regex to an input string.
-- | It is either an `Accept` state with a result of type `r`, or a
-- | (non-deterministic) transition function of the next input symbol.
data Thread c r =
  Thread
    { threadId :: ThreadId
    , step :: c -> CompiledRe c r
    }
  | Accept r

derive instance functorThread :: Functor (Thread c)

-- | Return the result of a thread, or `Nothing` if it's not an `Accept`.
getResult :: forall c r. Thread c r -> Maybe r
getResult (Accept r) = Just r
getResult (Thread _) = Nothing

-- | Feed a symbol into a thread.
stepThread :: forall c r. Thread c r -> c -> CompiledRe c r
stepThread (Thread t) c = t.step c
stepThread (Accept _) _ = emptyRe


-- | A `RE c r` that has been compiled into a non-deterministic state machine.
-- | `c` is the type of input symbols and `r` is the result type.
-- | A `CompiledRe` is a priority queue of `Thread`s.
-- | E.g., threads generated by the left part of `<|>` have higher
-- | priority than threads generated by the right part.
-- | Each non-result thread has a unique id.
newtype CompiledRe c r = CompiledRe (SQ.StateQueue (Thread c r))

derive instance functorCompiledRe :: Functor (CompiledRe c)

emptyRe :: forall c r. CompiledRe c r
emptyRe = CompiledRe SQ.empty

-- | List of all threads of a `CompiledRe`.
threads :: forall c r. CompiledRe c r -> List (Thread c r)
threads (CompiledRe sq) = fromFoldable sq

-- | Create a `CompiledRe` from a list of threads. It is recommended that all
-- | threads come from the same `CompiledRe`, unless you know what you're doing.
-- | However, it should be safe to filter out or rearrange threads.
fromThreads :: forall c r. List (Thread c r) -> CompiledRe c r
fromThreads ts = foldl addThread emptyRe ts

singleton :: forall c r. Thread c r -> CompiledRe c r
singleton t = fromThreads $ t : nil

-- | Check if the `CompiledRe` has no threads, in which case it will never match.
failed :: forall c r. CompiledRe c r -> Boolean
failed obj = null $ threads obj

-- | Extract the result values from all the result threads of a `CompiledRe`
results :: forall c r. CompiledRe c r -> List r
results obj = mapMaybe getResult $ threads obj

-- | Feed a symbol into a `CompiledRe`.
step :: forall c r. CompiledRe c r -> c -> CompiledRe c r
step (CompiledRe sq) c = foldl op emptyRe $ sq where
  op acc t = foldl addThread acc $ threads $ stepThread t c

-- | Add a thread to a `CompiledRe`. The new thread will have lower priority than the
-- | threads which are already in the `CompiledRe`.
-- | If a thread with the same id already exists in the queue, the
-- | `CompiledRe` is not changed.
addThread :: forall c r. CompiledRe c r -> Thread c r -> CompiledRe c r
addThread (CompiledRe q) t = CompiledRe $
  case t of
    Accept _ -> SQ.insert t q
    Thread { threadId: ThreadId i } -> SQ.insertUnique i t q

pureRe :: forall c r. r -> CompiledRe c r
pureRe r = singleton (Accept r)

-- | Compile a regular expression into a non-deterministic state machine.
compile :: forall c r. RE c r -> CompiledRe c r
compile e = runCont (go (renumber e)) pureRe where
  altRe a b = foldl addThread a $ threads b
  -- | Builds an NFSA using continuation passing style.
  -- | Given a regex `r` and continuation `k`, `go` builds a `CompiledRe` that
  -- | first matches `r` and then runs `k` on the result of `r`.
  go :: forall a. RE c a -> Cont (CompiledRe c r) a
  go = elimRE
    { eps: pure
    , fail: cont $ const emptyRe
    , symbol: \i p -> cont \k -> singleton $ Thread
      { threadId: i
      , step: (p >>> maybe emptyRe k)
      }
    , alt: \n1 n2 ->
        let
          a1 = go n1
          a2 = go n2
        in
          cont \k -> altRe (runCont a1 k) (runCont a2 k)
    , app: \n1 n2 -> go n1 <*> go n2
    , star: \g op z n ->
        let
          a = go n
          combine NonGreedy = altRe
          combine Greedy = flip altRe
          thrds z' k = combine g (k z') (runCont a $ \v -> thrds (op z' v) k)
        in
          cont $ thrds z
    , fmap: \f n -> f <$> go n
  }

-- | Give each `Symbol` node a unique `ThreadId`.
renumber :: forall c r. RE c r -> RE c r
renumber e =
  let
    fresh :: State Int ThreadId
    fresh = gets ThreadId <* (modify $ (+) 1)
    go :: forall t b. RE t b -> State Int (RE t b)
    go = elimRE
      { eps: \a -> pure $ pure a
      , fail: pure empty
      , symbol: \_ p -> flip Symbol p <$> fresh  -- <-- fresh
      , alt: \a1 a2 -> (<|>) <$> go a1 <*> go a2
      , app: \a1 a2 -> (<*>) <$> go a1 <*> go a2
      , star: \g f b a -> mkStar g f b <$> go a
      , fmap: \f a -> (<$>) f <$> go a
    }
  in
    evalState (go e) 0
