module Data.Regex.Applicative.Compile
  ( Thread
  , CompiledRe
  , compile
  , emptyObject
  , threads
  , failed
  , getResult
  , results
  , step
  , fromThreads
  , addThread
  ) where

import Control.Applicative (pure, (<$>), (<*), (<*>))
import Control.Monad.State (State, evalState, gets, modify)
import Data.Exists (runExists)
import Data.Foldable (foldl)
import Data.List.Lazy (List, fromFoldable, mapMaybe, nil, null, singleton, (:))
import Data.Maybe (Maybe(..), maybe)
import Data.Regex.Applicative.StateQueue as SQ
import Data.Regex.Applicative.Types (Apped(..), Greediness(..), Mapped(..), RE(..), Starred(..), ThreadId(..), elimRE, mkStar)
import Prelude (class Functor, const, flip, map, ($), (<<<), (<>), (>>>), (+))


-- | A `Thread` is one intermediate state (of possibly many) in the process of
-- | applying a regex to an input string.
-- | It is either an `Accept` state with a result of type `r`, or a
-- | (non-deterministic) transition function of the next input symbol.
data Thread c r =
  Thread
    { threadId :: ThreadId
    , step :: c -> List (Thread c r)
    }
  | Accept r

-- | Return the result of a thread, or `Nothing` if it's not an `Accept`.
getResult :: forall c r. Thread c r -> Maybe r
getResult (Accept r) = Just r
getResult (Thread _) = Nothing

-- | Feed a symbol into a thread.
stepThread :: forall c r. Thread c r -> c -> List (Thread c r)
stepThread (Thread t) c = t.step c
stepThread (Accept _) _ = nil


-- | A `RE c r` that has been compiled into a non-deterministic state machine.
-- | `c` is the type of input symbols and `r` is the result type.
-- | A `CompiledRe` is a priority queue of `Thread`s.
-- | E.g., threads generated by the left part of `<|>` have higher
-- | priority than threads generated by the right part.
-- | Each non-result thread has a unique id.
newtype CompiledRe c r = CompiledRe (SQ.StateQueue (Thread c r))

-- | List of all threads of a `CompiledRe`.
threads :: forall c r. CompiledRe c r -> List (Thread c r)
threads (CompiledRe sq) = fromFoldable sq

-- | Create a `CompiledRe` from a list of threads. It is recommended that all
-- | threads come from the same `CompiledRe`, unless you know what you're doing.
-- | However, it should be safe to filter out or rearrange threads.
fromThreads :: forall c r. List (Thread c r) -> CompiledRe c r
fromThreads ts = foldl addThread emptyObject ts

-- | Check if the `CompiledRe` has no threads, in which case it will never match.
failed :: forall c r. CompiledRe c r -> Boolean
failed obj = null $ threads obj

-- | Empty `CompiledRe` (with no threads)
emptyObject :: forall c r. CompiledRe c r
emptyObject = CompiledRe $ SQ.empty

-- | Extract the result values from all the result threads of a `CompiledRe`
results :: forall c r. CompiledRe c r -> List r
results obj = mapMaybe getResult $ threads obj

-- | Feed a symbol into a `CompiledRe`.
step :: forall c r. CompiledRe c r -> c -> CompiledRe c r
step (CompiledRe sq) c = foldl op emptyObject sq where
  op q t = foldl addThread q $ stepThread t c

-- | Add a thread to a `CompiledRe`. The new thread will have lower priority than the
-- | threads which are already in the `CompiledRe`.
-- | If a thread with the same id already exists in the queue, the
-- | `CompiledRe` is not changed.
addThread :: forall c r. CompiledRe c r -> Thread c r -> CompiledRe c r
addThread (CompiledRe q) t = CompiledRe $
  case t of
    Accept _ -> SQ.insert t q
    Thread { threadId: ThreadId i } -> SQ.insertUnique i t q


-- | Holds up to two continuations: one for when the match is empty, and
-- | one for when the match is non-empty.
-- | We use this to guarantee termination in the "Star" case, so that we don't
-- | match on the empty string forever.
data OneOrTwoConts a =
  OneCont a
  | TwoConts {
    empty :: a
    , nonEmpty :: a
  }
mkTwoConts :: forall a. a -> a -> OneOrTwoConts a
mkTwoConts e n = TwoConts { empty: e, nonEmpty: n }

-- | Get the continuation for handling empty matches.
emptyCont :: forall a. OneOrTwoConts a -> a
emptyCont (OneCont a) = a
emptyCont (TwoConts t) = t.empty

-- | Get the continuation for handling non-empty matches.
nonEmptyCont :: forall a. OneOrTwoConts a -> a
nonEmptyCont (OneCont a) = a
nonEmptyCont (TwoConts t) = t.nonEmpty

instance functorCont :: Functor OneOrTwoConts where
  map f (OneCont a) = OneCont (f a)
  map f (TwoConts { empty: a, nonEmpty: b } ) = mkTwoConts (f a) (f b)

-- | Compile a regular expression into a non-deterministic state machine.
compile :: forall c r. RE c r -> CompiledRe c r
compile e = fromThreads $ go (renumber e) (OneCont (\x -> Accept x : nil)) where
  go :: forall s. RE c s ->
                  OneOrTwoConts (s -> List (Thread c r)) ->
                  List (Thread c r)
  go (Eps a) = flip emptyCont a  -- empty match, use the empty continuation
  go (Fail) = const nil
  go (Symbol i p) = \k -> singleton $ Thread
    { threadId: i
    , step: (p >>> maybe nil (nonEmptyCont k))  -- non-empty match
    }
  go (Alt n1 n2) =
    let
      a1 = go n1
      a2 = go n2
    in \k -> a1 k <> a2 k
  go (App r) = runExists (\(Apped n1 n2) ->
    let
      a1 = go n1
      a2 = go n2
      f2 (OneCont k) = OneCont $ \aVal -> a2 $ OneCont $ k <<< aVal
      f2 (TwoConts { empty: ke, nonEmpty: kn } ) =
        let
          ene k1 k2 aVal = a2 $ mkTwoConts (k1 <<< aVal) (k2 <<< aVal)
        in
          mkTwoConts (ene ke kn) (ene kn kn)
    in a1 <<< f2) r
  go (Star r) = runExists (\(Starred g f b n) ->
    let
      a = go n
      combine Greedy = (<>)
      combine NonGreedy = flip (<>)
      threads b' k =
        combine g
          (a $
            mkTwoConts
              (const nil)
              (\v -> threads (f b' v) (OneCont $ nonEmptyCont k)))
          (emptyCont k b')
    in threads b) r
  go (Fmap r) = runExists (\(Mapped f n) ->
    let a = go n
    in \k -> a $ map ((>>>) f) k
  ) r

-- | Give each `Symbol` node a unique `ThreadId`.
renumber :: forall c r. RE c r -> RE c r
renumber e =
  let
    fresh :: State Int ThreadId
    fresh = gets ThreadId <* (modify $ (+) 1)
    go :: forall t b. RE t b -> State Int (RE t b)
    go = elimRE
      { eps: \a -> pure $ Eps a
      , fail: pure Fail
      , symbol: \_ p -> flip Symbol p <$> fresh  -- <-- fresh
      , alt: \a1 a2 -> Alt <$> go a1 <*> go a2
      , app: \a1 a2 -> (<*>) <$> go a1 <*> go a2
      , star: \g f b a -> mkStar g f b <$> go a
      , fmap: \f a -> (<$>) f <$> go a
    }
  in
    evalState (go e) 0
