--------------------------------------------------------------------
-- |
-- Module  : Text.Regex.Applicative.Object
-- Copyright : (c) Roman Cheplyaka
-- License   : MIT
--
-- Maintainer: Roman Cheplyaka <roma@ro-che.info>
-- Stability : experimental
--
-- This is a low-level interface to the regex engine.
--------------------------------------------------------------------
module Data.Regex.Applicative.Object
  ( ReObject
  , compile
  , emptyObject
  , threads
  , failed
  , isResult
  , getResult
  , results
  , step
  , stepThread
  , fromThreads
  , addThread
  ) where

import Data.Maybe

import Control.Applicative (pure, (<$>), (<*>))
import Control.Monad.Eff.Exception.Unsafe (unsafeThrow)
import Control.Monad.State (State, evalState, get, modify, put, runState)
import Data.Array (fromFoldable, mapMaybe, null)
import Data.Foldable (foldl)
import Data.Foldable as F
import Data.Lazy (force)
import Data.Newtype (class Newtype, unwrap, wrap)
import Data.Regex.Applicative.Compile as Compile
import Data.Regex.Applicative.StateQueue as SQ
import Data.Regex.Applicative.Types (RE, Thread(..), ThreadId(..), alt, app, eps, fail, fmap, rep, runFoldRE, runFoldRE_, symbol, threadId, void)
import Prelude (Unit, bind, discard, flip, ($), (+), (<<<))

-- | The state of the engine is represented as a \"regex object\" of type
-- @'ReObject' s r@, where @s@ is the type of symbols and @r@ is the
-- result type (as in the 'RE' type). Think of 'ReObject' as a collection of
-- 'Thread's ordered by priority. E.g. threads generated by the left part of
-- '<|>' come before the threads generated by the right part.
newtype ReObject s r = ReObject (SQ.StateQueue (Thread s r))

-- | List of all threads of an object. Each non-result thread has a unique id.
threads :: forall s r. ReObject s r -> Array (Thread s r)
threads (ReObject sq) = fromFoldable sq

-- | Create an object from a list of threads. It is recommended that all
-- threads come from the same 'ReObject', unless you know what you're doing.
-- However, it should be safe to filter out or rearrange threads.
fromThreads :: forall s r. Array (Thread s r) -> ReObject s r
fromThreads ts = foldl (flip addThread) emptyObject ts

-- | Check whether a thread is a result thread
isResult :: forall s r. Thread s r -> Boolean
isResult (Accept _) = true
isResult _ = false

-- | Return the result of a result thread, or 'Nothing' if it's not a result
-- thread
getResult :: forall s r. Thread s r -> Maybe r
getResult (Accept r) = Just r
getResult _ = Nothing

-- | Check if the object has no threads. In that case it never will
-- produce any new threads as a result of 'step'.
failed :: forall s r. ReObject s r -> Boolean
failed obj = null $ threads obj

-- | Empty object (with no threads)
emptyObject :: forall s r. ReObject s r
emptyObject = ReObject $ SQ.empty

-- | Extract the result values from all the result threads of an object
results :: forall s r. ReObject s r -> Array r
results obj =
  mapMaybe getResult $ threads obj

-- | Feed a symbol into a regex object
step :: forall s r. s -> ReObject s r -> ReObject s r
step s (ReObject sq) =
  let
    accum q t =
      case t of
        Accept _ -> q
        Thread { _threadCont: c } ->
          foldl (\q x -> addThread x q) q $ c s
    newQueue = foldl accum emptyObject sq
  in
    newQueue

-- | Feed a symbol into a non-result thread. It is an error to call 'stepThread'
-- on a result thread.
stepThread :: forall s r. s -> Thread s r -> Array (Thread s r)
stepThread s t =
  case t of
    Thread { threadId_: _, _threadCont: c } -> c s
    Accept _ -> unsafeThrow "stepThread on a result"

-- | Add a thread to an object. The new thread will have lower priority than the
-- threads which are already in the object.
--
-- If a (non-result) thread with the same id already exists in the object, the
-- object is not changed.
addThread :: forall s r. Thread s r -> ReObject s r -> ReObject s r
addThread t (ReObject q) =
  case t of
    Accept _ -> ReObject $ SQ.insert t q
    Thread { threadId_: ThreadId i } -> ReObject $ SQ.insertUnique (force i) t q

-- | Compile a regular expression into a regular expression object
compile :: forall s r. RE s r -> ReObject s r
compile =
  fromThreads <<<
  flip Compile.compile (\x -> [Accept x]) <<<
  renumber

-- help type inference out
newtype R t b = R (State ThreadId (RE t b))
derive instance newtypeR :: Newtype (R t b) _

renumber :: forall s a. RE s a -> RE s a
renumber e =
  let
    go1 :: forall t b. RE t b -> State ThreadId (RE t b)
    go1 x = case go x of R r -> r
    go :: forall t b. RE t b -> R t b
    go = runFoldRE {
        eps: R $ pure eps,
        symbol: \_ p -> R $ symbol <$> fresh <*> pure p,
        alt: \a1 a2 -> R $ alt <$> go1 a1 <*> go1 a2,
        app: \a1 a2 -> R $ app <$> go1 a1 <*> go1 a2,
        fail: R $ pure fail,
        fmap: \f a -> R $ fmap f <$> go1 a,
        rep: \g f b a -> R $ rep g f b <$> go1 a,
        void: \a -> R $ void <$> go1 a
    }
  in
    flip evalState (ThreadId (pure 1)) $ go1 e

fresh :: State ThreadId ThreadId
fresh = do
  t@(ThreadId i) <- get
  put $ ThreadId ((+) 1 <$> i)
  pure t
